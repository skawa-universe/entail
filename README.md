The `entail` crate provides a simplified interface to Google Cloud Datastore, enabling seamless 
conversion between Rust structs and Datastore entities. By leveraging the `#[derive(Entail)]` 
procedural macro, the library automatically handles the complex mapping logic required to 
persist and retrieve data.

At its core, `entail` consists of three primary components:
1. **The `EntityModel` Trait**: Generated by the derive macro to handle serialization.
2. **Datastore Types**: Native-feeling Rust representations of `Entity`, `Key`, and `Value`.
3. **The `DatastoreShell` and `Transaction`**: High-level clients that manage connections 
   and enforce atomicity.

### The `DatastoreShell` API

The `DatastoreShell` is the primary entry point for the library. It can operate as a 
**Standalone** client (using implicit transactions) or as a **Transactional** client tied to 
an ongoing operation.

* **Persistence**: Streamlined methods for `get_single`, `get_all`, and `commit` operations 
  using native Datastore types.
* **Identity Management**: Methods like `allocate_ids` (to obtain IDs for incomplete keys) 
  and `reserve_ids` (to prevent auto-allocation of specific IDs).
* **Query Execution**: Run complex queries via `run_query`, returning results as a 
  `QueryResult` with built-in pagination support.
* **Transaction Factory**: Acts as the basis for the `Transaction` runner, allowing you to 
  execute code within an atomic unit.

### Atomic Transactions

The `Transaction` struct provides a robust runner for executing asynchronous code blocks 
atomically. It handles the complexities of Datastore transactions, including:

* **Automatic Management**: Handles `begin_transaction` and ensures either a `commit` or 
  an automatic `rollback` occurs.
* **Retry Logic**: Implements sophisticated retry rules (including exponential backoff 
  and jitter) for concurrency conflicts (ABORTED) or transient network issues.
* **TransactionShell**: Provides a specific shell instance (`TransactionShell`) inside the 
  closure that dereferences to `DatastoreShell` for familiar API access.

### The `EntityModel` Trait

For each struct annotated with `#[derive(Entail)]`, the `entail_derive` macro generates an
implementation of the `EntityModel` trait:

* `to_ds_entity`: Converts your Rust struct into an `entail::ds::Entity`.
* `from_ds_entity`: Converts an `entail::ds::Entity` back into your Rust struct.
* `adapter`: Returns a static `EntityAdapter` providing model-specific utilities for 
  key creation and query building.

### The `#[entail]` Attribute

The `#[entail]` attribute is used to customize the behavior of the `#[derive(Entail)]` macro.
It can be applied at both the **struct** level and the **field** level.

---

### Struct-Level Attributes

These attributes are placed on the struct definition to configure global behavior.

* `#[entail(rename_all = "camelCase")]`
    This option specifies a naming convention for all fields within the struct, this `camelCase`
    being the default, an empty string will leave the field names alone by default.
    The generated Datastore property names will follow this convention. Supported
    values are `"camelCase"`, `"snake_case"`, `"PascalCase"`, and the empty string for leaving
    it as-is.

* `#[entail(name = "KindName")]`
    This attribute overrides the default Datastore **Kind** name, which is inferred from the
    struct's name.

---

### Field-Level Attributes

By default, fields are **not** persisted to Datastore unless they have a `#[entail]` attribute.
You can mark a field for mapping by simply adding `#[entail]` to it.

Here are the available options for fields:

* `#[entail(key)]`
    Marks the field as the **primary key** for the entity. A struct must have exactly one primary
    key field. This field's value will be used to populate the `name` or `id` component of the
    `entail::ds::Key`. If a field is named `key` and has the `#[entail]` attribute, it's automatically
    treated as the primary key unless overridden.

* `#[entail(field)]`
    Forces a field to be treated as a regular Datastore property, even if its name or other
    attributes might suggest it's a primary key. This is useful for disambiguation, for example,
    on a field named `key`.

* `#[entail(text)]`
    This option specifies that the string field should be encoded as a **large block of text**.
    This is primarily for **compatibility with App Engine Standard Java clients** (by setting
    the property's internal `meaning` to `entail::ds::MEANING_TEXT`). Cloud Datastore does not
    strictly require this flag for long strings, as any unindexed string property can store
    values up to 1 MiB. However, this flag explicitly marks the field for correct decoding as a
    Text type in older environments. **Text properties are always unindexed.**

* `#[entail(name = "custom_name")]`
    Overrides the Datastore property name for a specific field. By default, the property name is
    the same as the Rust field name, potentially modified by the `rename_all` struct attribute.

* `#[entail(indexed)]`
    Ensures the field is always indexed in Datastore. This is the **default behavior** for any
    field with a `#[entail]` attribute. You only need to use this to explicitly state that a
    field should be indexed.

* `#[entail(unindexed)]`
    Prevents the field from being indexed. This is useful for large or frequently updated fields
    that don't need to be queried.

* `#[entail(unindexed_nulls)]`
    This option is specifically for `Option<T>` fields. It ensures the field is only indexed if
    its value is `Some(T)`. If the value is `None`, the property is still created with a `Null`
    value but will not be indexed.

---

### Type Mapping

The `entail` library handles the conversion between common Rust types and `entail::ds::Value`s.

| Rust Type | `entail::ds::Value` | Notes |
| :--- | :--- | :--- |
| `String`, `Cow<'static, str>` | `UnicodeString` | |
| `i32`, `i64`, `u32` | `Integer` | 32 bit types are mapped to `i64`. |
| `f32`, `f64` | `FloatingPoint` | |
| `bool` | `Boolean` | |
| `Vec<u8>` | `Blob` | |
| `entail::ds::Key` | `Key` | |
| `Vec<T>` | `Array` | The elements of the vector are mapped to `Value`s. |
| `Option<T>` | `T` or `Null` | A value of `Some(T)` is converted to the corresponding `Value`, while `None` becomes `Value::Null`. On deserialization, `Option<T>` can be populated from `Null`, a single `Value`, or an array of one `Value`. An empty array becomes `None`, and an array with more than one element will result in an error. |
